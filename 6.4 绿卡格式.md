绿卡格式{.text-center}
----------

&nbsp;

### 隐身份护照

真身服务点除了能颁发泛身份护照（generic passport）外，还颁发隐身份护照（undisclosed passport，下面简称隐护照），隐身份是泛身份下一级账号的身份，它专用作绿卡的属主。

泛身份是由某用户小号账号下按 `alt/0/0/child1` 路径推导的账号，隐身份则是泛身份下一级 child2 序号的衍生账号。不过，推导隐身份时，相应泛身份账号的 chaincode 要置空（即，32 字节均取 `'\x00'` 值），推导公式如下：

```
generic_acc = alt_account.child(0).child(0).child(child1)
generic_acc = HDWallet.from_pubkey(generic_acc.publicKey(), b'\x00' * 32)
undisclosed_acc = generic_acc.child(child2)
``` 

真身服务点生成隐身份护照的规则与生成泛身份护照相同，除了 rootcode 字段计算方法有差别。

泛护照的验根码这么计算：`hashlib.sha256(disclosed_real_pubkey + b':' + child1)[:4]`，隐护照的验根码算法要改成：`hashlib.sha256(generic_acc.publicKey() + b':' + child2)[:4]`，也就是，取它的父级（泛身份）账号公钥，与相对路径 child2 串接形成字串算 hash 值，再取 hash 值的前 4 字节。

总结一下，泛身份就是路径为 `alt/0/0/child1` 的身份账号，隐身份是 `alt/0/0/child1/child2`，隐身份的验根码 rootcode 的算法与它所属的泛身份公钥及衍生序号 child2 相关。

实践中，child2 采用两级推导，比如泛身份为 `alt/0/0/123451234`，其下隐身份取 `alt/0/0/123451234/987654321/123456789`，两级比一级更安全。

&nbsp;

### 绿卡申请流程

NBC DID 设计签证换绿卡，而不是直接拿签证登录应用网站，主要想达到两个目标：一是用长期凭证换短期凭证，签证有效期通常很长，最长允许有 20 年，显然这个周期与用户登录事务控制的时长不匹配；二是形成隔离，应用网站颁发签证，它清楚目标用户是谁，所以能实施数据挖掘，换发绿卡后，授权目标被迁移，由隐身份代替原先的泛身份，应用网站因此丧失跟踪对象。

绿卡由通密服务点（Crypto Server Point）颁发，通密服务点要求由权威机构设立（多个机构可以设立多个服务点），或者由某个区块链中的挖矿节点承担。

通密服务点至少设置两个管理账号，其一是平台账号（platform account），代表权威机构的平台管理员，或区块链软件平台的管理员，其二是生产商账号（product account），代表当前节点所有者的账号。

拿签证换发绿卡，需由签证中记录的被授权用户（在签证的 target 字段指明）发起。用户提交给通密服务点的内容较多，除了应用网站颁发的签证，还有如下参数：

1. 被授权用户的隐身份序号，即 child2 序号
2. 由真身服务点颁发的隐身份护照，即，取被授权泛身份下级序号为 child2 的常规衍生账号
3. 当前时间 card_tm，将记录到绿卡的 now_time 字段
4. 应用网站管理员的公钥

这些参数在下图记为 `arguments`。

```
 +-----------+
 | visa card +---+
 +-----------+   |   +---------------------+   +------------+
                 +-->| Crypto Server Point +-->| green card |
 +-----------+   |   +---------------------+   +------------+
 | arguments +---+
 +-----------+
```

通密服务点在创建绿卡前，尝试从用授权目标的泛身份推导其下序号为 child2 的隐身份账号，如果推出导账号的公钥与传入参数隐身份护照中记录的公钥一致，表明当前泛身份与隐身份具备同属关系。也就是，签证 visa 登记的被授权对象，与即将生成的绿卡的主人（隐身份）同属一人。 

在绿卡生成前，通密服务点还验证签证与隐护照的签名，确保这两者未被伪造。

&nbsp;

### 绿卡格式

绿卡定义如下字段：

1. rootcode 字段  
绿卡属主隐身份的验根码，4 字节长。从隐护照的 rootcode 字段拷贝而来。

2. login_session 字段  
会话登录因子，占用 20 字节。

3. time_session 字段  
会话时效因子，占用 20 字节。

4. realm 字段  
领域字段，最长限制 96 字节。从 visa 卡的 realm 字段拷贝而来。

5. session_data 字段  
会话配置，最长取 127 字节，表达当前角色所拥有权限的基础上叠加的权限参数，从 visa 卡的 session_data 字段拷贝而来。

6. admin_figerprint 字段  
管理员指纹，固定取当前应用网站管理员账号的 ripemd_hash 摘要值的前 4 字节，从 visa 卡的 admin_figerprint 字段拷贝而来。

7. cert_expired 字段  
证书失效时间，用 4 字节表达本证书的失效时间（以分钟为单位，按 BigEndian 格式存贮）。

8. now_time 字段  
当前时间，占用 5 字节，首字节表达 sess_type 值，取 visa 卡中 now_time 字段首字节，后 4 字节为当前时间的分钟值（即传入的 card_tm），按 BigEndian 格式存贮。card_tm 取值会被 TEE 验证，与当前实际时间偏差超出 5 分钟视为非法。

9. signature 字段  
签名字段，占用 64 字节，证书颁发者（即 TEE 内 `PLT-ACC` 根账号）针对本证书主体内容给出的签名。

说明，绿卡中不设 account 字段，持绿卡登录应用网站时，用户需同时传递绿卡属主（即隐身份）的 33 字节公钥值。

&nbsp;

### 从 seed_secret 到 time_session 及 login_session 的推导

签证 visa 中记录了 48 字节长的种密 seed_secret，通密服务点对 seed_secret 解密，得到 16 字节长的应用网站的 secret 值，然后从传入的 visa 提取 realm 与 session_data 字段，再结合传入的隐护照中的隐身份 pubkey，以及当前时间 card_tm，按如下算法推导 time_session 与 login_session。

``` python
ha1 = ripemd_hash(b'%s:%i' % (realm,card_tm))
ha2 = ripemd_hash(b'%s:%s:%i:%s' % (pubkey,realm,card_tm,session_data))
time_session = bytes([ha1[i] ^ ha2[i] for i in range(20)])
login_session = ripemd_hash(secret + ha2)
```

其中，time_session 取值由 ha1 与 ha2 逐字节异或再串接而成。最后通密服务点生成绿卡输出时，写入上述 time_session 与 login_session 结果值。

实践中，应用网站通过签证加密传送的 secret，应从另一个机密字串 secret0 推导，推导过程结合当前签证采用的 realm 与 session_data 字段值。公式如下：

``` python
secret = hashlib.sha256(hashlib.sha256(b'%s:%s:%s' % (secret0,realm,session_data)).digest())
secret = secret.digest()[:16]
```

这里，secret0 是应用网站的原始机密，它的取值应该长期不变，而每次发行签证时所用的 secret 取值会随 realm 与 session_data 变化而变化。这个设计相当于给原始机密加了一层保险，即使某个签证的 secret 被黑客破解，想从 secret 反推 secret0 做不到，所以，即使对手破解了一份签证，并不能将破解扩大到其它签证。 

&nbsp;

### 持绿卡登录的授权验证

当用户持绿卡登录应用网站时，网站服务器按如下步骤验证 login_session 与 time_session 取值。

第 1 步，从绿卡取 realm 与 session_data 字段值，再从 now_time 字段提取该卡创建时间 card_tm，然后用当前绿卡属主公钥 pubkey，推导 ha1 与 ha2 取值。

``` python
ha1 = ripemd_hash(b'%s:%i' % (realm,card_tm))
ha2 = ripemd_hash(b'%s:%s:%i:%s' % (pubkey,realm,card_tm,session_data))
```

第 2 步，从绿卡取 time_session 字段值，计算 `bytes(time_session[i] ^ [ha1[i] for i in range(20)])` 结果值是否与 ha2 相同。

如果相同，表明本卡的 time_session 推导算法是预期的，card_tm 正是被通密服务点检验过的，能准确指示绿卡的发行时间。

如前述，time_session 由 ha1 与 ha2 逐字节异或再串接而成，反过来，ha2 也可由 time_session 与 ha1 逐字节异或后串接推导回来。

第 3 步，从绿卡取 login_session 字段值，用网站 secret 明文推导 login_session，看看两者是否一致。

``` python
login_session = ripemd_hash(secret + ha2)
```

因为推导 ha2 结合了如下因素：

1. 绿卡属主身份 pubkey
2. 登录的权限特征：realm 与 session_data
3. 绿卡授权时间 card_tm

所以，这一步推导 login_session 结果与卡中记录的同名字段若相同，一方面表明，对应网站的 secret 信息已被正确结合到 login_session 推导，secret 未被伪造，另一方面，登录凭证的关健授权信息已纳入推导过程，授权的真实性获得验证。

&nbsp;

### 零知识证明

在通密服务点完成的签证换绿卡处理过程，有多处运用了零知识证明技术，列举如下：

1. 在不泄露用户账号任何私钥的情况下，以常规衍生（只需公钥与链码）推导论证了泛身份与隐身份之间的同属关系。

2. 最终的绿卡虽然结合了应用网站的 secret，由 `ripemd_hash(secret+ha2)` 算法隐匿了 secret 取值，绿卡提供授权凭（login_session 字段）结合了网站的 secret，但不泄露 secret 原值。

3. 应用网站颁发的签证虽已列明 realm、session_data 等与授权相关的字段，却无法依据这些字段信息推导某个中间值，以便拿它与相关绿卡中某些字段（或某些中间推导值）实施关联，从而隔断了签证与绿卡之间的关联关系。（请参见上面 ha1、ha2、time_session、login_session 等推导过程，card_tm 与隐身份 pubkey 参与散列运算，起到了混淆效果）

每份绿卡都设计了时效性（正常 2 周后过期），时效本身有助于提高安全性，另外也方便网站管理。需缓冲回溯的时间缩短了，如果采用签证中登记的有效期，延续时间可能很长，不利于与商业规则变更有关的失效期管理。
